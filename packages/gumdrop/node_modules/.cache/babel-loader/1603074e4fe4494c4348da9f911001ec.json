{"ast":null,"code":"import _slicedToArray from\"/home/haeun/metaplex/js/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _toConsumableArray from\"/home/haeun/metaplex/js/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _createForOfIteratorHelper from\"/home/haeun/metaplex/js/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _classCallCheck from\"/home/haeun/metaplex/js/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"/home/haeun/metaplex/js/node_modules/@babel/runtime/helpers/esm/createClass.js\";import{keccak_256}from'js-sha3';export var MerkleTree=/*#__PURE__*/function(){function MerkleTree(leafs){_classCallCheck(this,MerkleTree);this.leafs=void 0;this.layers=void 0;this.leafs=leafs.slice();this.layers=[];var hashes=this.leafs.map(MerkleTree.nodeHash);while(hashes.length>0){console.log('Hashes',this.layers.length,hashes);this.layers.push(hashes.slice());if(hashes.length===1)break;hashes=hashes.reduce(function(acc,cur,idx,arr){if(idx%2===0){var nxt=arr[idx+1];acc.push(MerkleTree.internalHash(cur,nxt));}return acc;},Array());}}_createClass(MerkleTree,[{key:\"getRoot\",value:function getRoot(){return this.layers[this.layers.length-1][0];}},{key:\"getProof\",value:function getProof(idx){return this.layers.reduce(function(proof,layer){var sibling=idx^1;if(sibling<layer.length){proof.push(layer[sibling]);}idx=Math.floor(idx/2);return proof;},[]);}},{key:\"getHexRoot\",value:function getHexRoot(){return this.getRoot().toString('hex');}},{key:\"getHexProof\",value:function getHexProof(idx){return this.getProof(idx).map(function(el){return el.toString('hex');});}},{key:\"verifyProof\",value:function verifyProof(idx,proof,root){var pair=MerkleTree.nodeHash(this.leafs[idx]);var _iterator=_createForOfIteratorHelper(proof),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var item=_step.value;pair=MerkleTree.internalHash(pair,item);}}catch(err){_iterator.e(err);}finally{_iterator.f();}return pair.equals(root);}}],[{key:\"nodeHash\",value:function nodeHash(data){return Buffer.from(keccak_256.digest([0x00].concat(_toConsumableArray(data))));}},{key:\"internalHash\",value:function internalHash(first,second){if(!second)return first;var _sort=[first,second].sort(Buffer.compare),_sort2=_slicedToArray(_sort,2),fst=_sort2[0],snd=_sort2[1];return Buffer.from(keccak_256.digest([0x01].concat(_toConsumableArray(fst),_toConsumableArray(snd))));}},{key:\"verifyClaim\",value:function verifyClaim(leaf,proof,root){var pair=MerkleTree.nodeHash(leaf);var _iterator2=_createForOfIteratorHelper(proof),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var item=_step2.value;pair=MerkleTree.internalHash(pair,item);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return pair.equals(root);}}]);return MerkleTree;}();","map":{"version":3,"sources":["/home/haeun/metaplex/js/packages/gumdrop/src/utils/merkleTree.ts"],"names":["keccak_256","MerkleTree","leafs","layers","slice","hashes","map","nodeHash","length","console","log","push","reduce","acc","cur","idx","arr","nxt","internalHash","Array","proof","layer","sibling","Math","floor","getRoot","toString","getProof","el","root","pair","item","equals","data","Buffer","from","digest","first","second","sort","compare","fst","snd","leaf"],"mappings":"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","sourcesContent":["import { keccak_256 } from 'js-sha3';\n\nexport class MerkleTree {\n  leafs: Array<Buffer>;\n  layers: Array<Array<Buffer>>;\n\n  constructor(leafs: Array<Buffer>) {\n    this.leafs = leafs.slice();\n    this.layers = [];\n\n    let hashes = this.leafs.map(MerkleTree.nodeHash);\n    while (hashes.length > 0) {\n      console.log('Hashes', this.layers.length, hashes);\n      this.layers.push(hashes.slice());\n      if (hashes.length === 1) break;\n      hashes = hashes.reduce((acc, cur, idx, arr) => {\n        if (idx % 2 === 0) {\n          const nxt = arr[idx + 1];\n          acc.push(MerkleTree.internalHash(cur, nxt));\n        }\n        return acc;\n      }, Array<Buffer>());\n    }\n  }\n\n  static nodeHash(data: Buffer): Buffer {\n    return Buffer.from(keccak_256.digest([0x00, ...data]));\n  }\n\n  static internalHash(first: Buffer, second: Buffer | undefined): Buffer {\n    if (!second) return first;\n    const [fst, snd] = [first, second].sort(Buffer.compare);\n    return Buffer.from(keccak_256.digest([0x01, ...fst, ...snd]));\n  }\n\n  getRoot(): Buffer {\n    return this.layers[this.layers.length - 1][0];\n  }\n\n  getProof(idx: number): Buffer[] {\n    return this.layers.reduce((proof, layer) => {\n      const sibling = idx ^ 1;\n      if (sibling < layer.length) {\n        proof.push(layer[sibling]);\n      }\n\n      idx = Math.floor(idx / 2);\n\n      return proof;\n    }, []);\n  }\n\n  getHexRoot(): string {\n    return this.getRoot().toString('hex');\n  }\n\n  getHexProof(idx: number): string[] {\n    return this.getProof(idx).map(el => el.toString('hex'));\n  }\n\n  verifyProof(idx: number, proof: Buffer[], root: Buffer): boolean {\n    let pair = MerkleTree.nodeHash(this.leafs[idx]);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n\n  static verifyClaim(leaf: Buffer, proof: Buffer[], root: Buffer): boolean {\n    let pair = MerkleTree.nodeHash(leaf);\n    for (const item of proof) {\n      pair = MerkleTree.internalHash(pair, item);\n    }\n\n    return pair.equals(root);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}